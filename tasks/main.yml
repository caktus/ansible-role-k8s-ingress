---
# Sanity check so we don't accidentally remove all access to the cluster on AWS:
- when: (k8s_cluster_type == "aws") and (k8s_iam_users|length == 0)
  fail:
    msg: "Set k8s_iam_users to a list of IAM usernames who should have access to manage the cluster"

- when: (k8s_cluster_type != "aws") and k8s_ci_create_user
  fail:
    msg: "Setting k8s_ci_create_user is only supported on AWS"

# cert-manager install process adapted from:
# https://cert-manager.io/docs/installation/kubernetes/#installing-with-regular-manifests
- name: Create namespace for cert-manager
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    wait: yes
    validate:
      fail_on_error: yes
      strict: yes
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: cert-manager
  register: cert_manager

- name: Temporarily disable validation for cert-manager namespace
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    wait: yes
    wait_timeout: "{{ k8s_wait_timeout }}"
    validate:
      fail_on_error: yes
      strict: yes
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: cert-manager
        labels:
          certmanager.k8s.io/disable-validation: "true"

- name: Deploy cert-manager and Let's Encrypt
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    wait: yes
    # FIXME: cert-manager.yaml doesn't validate, so this is disabled for now.
    # Maybe the next version will validate?
    # validate:
    #   fail_on_error: yes
    #   strict: yes
    definition: "{{ lookup('template', item) }}"
  with_items:
    # https://cert-manager.io/docs/
    - cert-manager.yaml
    - letsencrypt/issuers.yaml


- name: Re-enable validation for cert-manager namespace
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    wait: yes
    wait_timeout: "{{ k8s_wait_timeout }}"
    validate:
      fail_on_error: yes
      strict: yes
    definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: cert-manager
        labels:
          certmanager.k8s.io/disable-validation: "false"

# ingress-nginx installation process adapted from:
# https://kubernetes.github.io/ingress-nginx/deploy/#prerequisite-generic-deployment-command
- name: Deploy Nginx Ingress Controller
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    wait: yes
    wait_timeout: "{{ k8s_wait_timeout }}"
    validate:
      fail_on_error: yes
      strict: yes
    definition: "{{ lookup('template', item) }}"
  with_items:
    - ingress-nginx/mandatory.yaml
    - ingress-nginx/cloud-generic.yaml
    - ingress-nginx/patch-configmap.yaml
  when: k8s_install_ingress_controller

- name: Deploy Papertrail logspout
  k8s:
    context: "{{ k8s_context|mandatory }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    state: "{{ k8s_papertrail_logspout_enabled | ternary('present', 'absent') }}"
    wait: yes
    wait_timeout: "{{ k8s_wait_timeout }}"
    validate:
      fail_on_error: yes
      strict: yes
    # Stored locally to convert to template
    # https://help.papertrailapp.com/assets/files/papertrail-logspout-daemonset.yml
    definition: "{{ lookup('template', 'papertrail/papertrail-logspout-daemonset.yml') }}"
  tags: [logspout]

- name: "Install kube-state-metrics {{ k8s_newrelic_kube_state_metrics_version }}"
  k8s:
    context: "{{ k8s_context }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    state: "{{ k8s_newrelic_enabled | ternary('present', 'absent') }}"
    wait: yes
    validate:
      fail_on_error: yes
      strict: yes
    definition: "{{ lookup('url', item, split_lines=False) }}"
  tags: [metrics]
  with_items:
  - "https://raw.githubusercontent.com/kubernetes/kube-state-metrics/{{ k8s_newrelic_kube_state_metrics_version }}/examples/standard/cluster-role-binding.yaml"
  - "https://raw.githubusercontent.com/kubernetes/kube-state-metrics/{{ k8s_newrelic_kube_state_metrics_version }}/examples/standard/cluster-role.yaml"
  - "https://raw.githubusercontent.com/kubernetes/kube-state-metrics/{{ k8s_newrelic_kube_state_metrics_version }}/examples/standard/service-account.yaml"
  - "https://raw.githubusercontent.com/kubernetes/kube-state-metrics/{{ k8s_newrelic_kube_state_metrics_version }}/examples/standard/deployment.yaml"
  - "https://raw.githubusercontent.com/kubernetes/kube-state-metrics/{{ k8s_newrelic_kube_state_metrics_version }}/examples/standard/service.yaml"

- name: Install New Relic Infrastructure Agent
  k8s:
    context: "{{ k8s_context }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    state: "{{ k8s_newrelic_enabled | ternary('present', 'absent') }}"
    wait: yes
    validate:
      fail_on_error: yes
      strict: yes
    # Stored locally to convert to template
    # https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-installation-configuration
    definition: "{{ lookup('template', 'newrelic/newrelic-infrastructure-k8s-latest.yaml') }}"
  tags: [metrics]

- name: Grant access to IAM users if aws
  when: k8s_cluster_type == "aws"
  k8s:
    definition: "{{ lookup('template', 'aws/cluster-auth.yaml') }}"
    context: "{{ k8s_context }}"
    kubeconfig: "{{ k8s_kubeconfig }}"
    state: present
    wait: yes
    validate:
      fail_on_error: yes
      strict: yes

- name: Create CI user
  iam:
    name: "{{ k8s_ci_username }}"
    state: present
    iam_type: user
    profile: "{{ k8s_ci_aws_profile }}"
  when: k8s_ci_create_user
  register: ci_user

- debug:
    msg: |
      IAM user {{ k8s_ci_username }} has been created.
      Create an access_key in the AWS IAM console and store them in your CI's environment variables.
  when: ci_user is changed

- name: Attach inline policy to user
  iam_policy:
    iam_type: user
    iam_name: "{{ k8s_ci_username }}"
    policy_name: "ECRPush"
    state: present
    policy_json: "{{ lookup( 'template', 'aws/ECRPush.json.j2') }}"
    profile: "{{ k8s_ci_aws_profile }}"
  when: k8s_ci_create_user
